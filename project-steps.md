# Проект: Пошаговая стратегия (консольная версия)

---

## Описание проекта

В рамках курса студенты создают консольную пошаговую стратегию, вдохновлённую механикой серии **Heroes of Might and Magic**.  
Проект развивается от простейшей карты и перемещений игрока до полноценной игры с боями, зданиями, ресурсами и монстрами. Каждая лабораторная работа добавляет новые элементы и закрепляет определённые темы языка C#.

### Общая концепция
- **Карта**  
  Текстовое поле (матрица символов), отображаемое в консоли. На карте размещаются:
  - игрок,  
  - ресурсы,  
  - строения,  
  - монстры.  
  Обозначения:
  - игрок и захваченные постройки отображаются своим цветом,  
  - нейтральные здания — серые.  

- **Игрок**  
  Игрок может перемещаться по карте на ограниченное количество клеток за день.  
  Количество шагов зависит от:
  - типа игрока (Рыцарь, Маг, Рейнджер),  
  - уровня,  
  - временных бонусов (например, конюшня даёт +к перемещению на неделю).  

  Характеристики:
  - 3 слота для юнитов (по одному типу в каждом, максимум 99 в слоте).  
    - Рыцарь имеет 4 слота.  
  - 2 слота для экипировки (оружие, доспех).  
  - Маг наносит дополнительный урон магией.  
  - Рейнджер ходит дальше других.  

- **Постройки**
  - **Замок** — генерирует ресурсы и юнитов раз в неделю, в зависимости от построек внутри.  
  - **Ресурсные строения** — лесопилка (дерево), каменоломня (камень), шахта (золото).  
  - **Бонусные строения** —  
    - Конюшня: даёт +к передвижению на неделю,  
    - Колодец: восполняет очки заклинаний.  

- **Ресурсы**  
  - Случайно разбросаны по карте.  
  - Подбираются единовременно.  
  - Поступают каждую неделю от захваченных зданий.  

- **Монстры**
  - Имеют радиус агрессии: бой начинается, если игрок заходит в него.  
  - Могут состоять из нескольких слотов (как у игрока).  
  - Типы:  
    - Гоблин: слабый, но многочисленный.  
    - Хобгоблин: сильный, но в слотах встречается редко.  

- **Игровое время**
  - Основная единица — неделя.  
  - Раз в неделю:
    - начисляются ресурсы,  
    - обновляется набор юнитов для найма.  

---

## Лабораторные работы

### Лабораторная работа 1  
**Темы:** символы, строки, численные типы данных, ввод/вывод в консоль, `if-else`, `for`, `while`  

**Задачи:**
1. Реализовать простую текстовую карту в консоли (например, 10x10), заполненную символами (`.`, `#`).  
2. Добавить символ игрока (`@`), который может двигаться по карте.  
3. Реализовать ввод с клавиатуры для перемещения игрока (WASD).  
4. Ограничить передвижение по границам карты.  
5. Добавить проверку на тип клетки (например, стена `#` — непроходима).  
6. Выводить на экран координаты игрока и количество сделанных шагов.  

**Примеры промтов для изучения:**  
- Объясни разницу между типами `int`, `double`, `char`, `string` в C#.  
- Покажи пример программы на C#, которая считывает строку из консоли и выводит её длину.  
- Напиши пример использования цикла `for` и цикла `while` для вывода чисел от 1 до 10.  
- Как с помощью `if-else` проверить, что введённое число положительное, отрицательное или ноль?
- Как в C# вывести текст в консоль и считать строку с клавиатуры?  
- Как считать одиночный символ нажатой клавиши в консоли без необходимости нажимать Enter?  
- Покажи пример кода, где игрок перемещается по координатам на поле 10x10 при нажатии клавиш W, A, S, D.  
- Как в C# очистить консоль и перерисовать карту после каждого хода?  
- Объясни, как организовать цикл игры, который обрабатывает ввод и обновляет состояние карты. 

---

### Лабораторная работа 2  
**Темы:** массивы, методы, файловый ввод/вывод, `DateTime`  

**Цель**: научиться управлять игроком на карте, считывать клавиши, сохранять и загружать состояние игры, а также выводить карту и нижнюю панель с информацией о ходе, дне недели и ресурсах игрока.

### Задачи
1. **Работа с массивами и методами:**  
   - Хранить карту в двумерном массиве.  
   - Разбросать ресурсы (`G`, `W`, `S`) и строения на карте.  
   - Создать методы для отображения карты и нижней информационной панели.  

2. **Файловый ввод/вывод и время:**  
   - Сохранять и загружать состояние игры в файл.  
   - Отображать текущий день и неделю.  

3. **Считывание клавиш и управление игроком:**  
   - Считывать нажатия клавиш без Enter (`Console.ReadKey(true)`).  
   - Перемещать игрока по карте с помощью W, A, S, D.  
   - Настроить клавиши для сохранения/загрузки игры и завершения дня.  

4. **Отрисовка и перерисовка:**  
   - Отображать карту на консоли и игрока на ней.  
   - Перерисовывать экран после каждого действия (`Console.Clear()`).  
   - Показывать нижнюю панель с номером недели, текущим днем и количеством ресурсов.  
   - Реализовать отдельную команду для отображения информации об игроке (очки движения, очки заклинаний, экипировка, слоты юнитов).    

**Краткое объяснение**
Консольная игра требует постоянного обновления экрана после действий игрока. Для этого карта и информационная панель выводятся методами, которые вызываются после каждого события. События включают: движение игрока, завершение дня, подбор ресурсов, сохранение и загрузку. Обработка нажатий клавиш позволяет управлять ходом игры без ввода строк и Enter.

**Примеры промтов для изучения:**  
- Объясни разницу между одномерным и двумерным массивом в C#.  
- Покажи пример метода, который принимает массив чисел и возвращает их сумму.  
- Как в C# работать с файлами: записывать строки в текстовый файл и считывать их обратно?  
- Напиши пример программы, которая выводит текущую дату и время с помощью `DateTime`.

**Примеры промтов для нейронки**
1. Как хранить карту в двумерном массиве и выводить её в консоль?  
2. Пример метода для подсчета ресурсов игрока и отображения нижней панели.  
3. Как использовать `Console.ReadKey(true)` для интерактивного перемещения игрока?  
4. Как реализовать сохранение и загрузку игры в файл с помощью StreamWriter/StreamReader?  
5. Пример цикла игры с перерисовкой карты и нижней панели после каждого действия.  
6. Как связать клавиши W, A, S, D с перемещением игрока по массиву карты?  
7. Пример отображения информации об игроке (очки движения, очки заклинаний, слоты юнитов) по отдельной клавише.  
8. Как использовать `DateTime` для отображения текущего дня и недели в игре?  
9. Как очистить консоль и заново отрисовать карту с игроком и ресурсами?  
10. Пример метода, который обновляет нижнюю панель после каждого хода игрока. 


---

### Лабораторная работа 3  
**Темы:** передача параметров по ссылке и значению, рекурсия, `enum`, кортежи  

**Задачи:**
1. Создать перечисление `PlayerType { Knight, Mage, Ranger }`.  
2. Добавить возможность выбора типа игрока при старте.  
3. Хранить характеристики игрока (скорость, сила магии, количество слотов для юнитов) в кортеже.  
4. Реализовать метод для расчета доступного количества ходов в день в зависимости от типа.  
5. Добавить рекурсивный метод для отрисовки карты (например, проход по строкам).  
6. Использовать параметры по ссылке для изменения характеристик игрока (например, временный бонус из конюшни).  

**Примеры промтов для изучения:**  
- Объясни разницу между передачей параметров по значению и по ссылке в C#.  
- Напиши пример функции с рекурсией, которая вычисляет факториал числа.  
- Что такое перечисление (`enum`) и как им пользоваться? Приведи пример.  
- Покажи пример кортежа в C#, который хранит имя и возраст человека.  

---

### Лабораторная работа 4  
**Темы:** классы и объекты, структуры, конструкторы, модификаторы видимости, свойства, методы, `const`, `readonly`  

**Задачи:**
1. Создать класс `Player` с полями: имя, тип, количество ходов, инвентарь, массив юнитов.  
2. Создать структуру `UnitSlot` (тип юнита, количество).  
3. Добавить свойства и константы (например, максимальное количество юнитов в слоте = 99).  
4. Реализовать методы для добавления и удаления юнитов.  
5. Создать конструктор для игрока, инициализирующий его характеристики.  
6. Ограничить доступ к внутренним данным с помощью модификаторов (`private`, `public`, `protected`).  

**Примеры промтов для изучения:**  
- Объясни разницу между классами и структурами в C#.  
- Покажи пример конструктора в классе и объясни его назначение.  
- Что такое свойства (`get`/`set`) и как они используются?  
- Объясни разницу между `const` и `readonly` в C#.  

---

### Лабораторная работа 5  
**Темы:** инкапсуляция, наследование, полиморфизм  

**Задачи:**
1. Создать базовый класс `Building`.  
2. Унаследовать классы: `Castle`, `ResourceBuilding`, `BonusBuilding`.  
3. Реализовать полиморфный метод `ActivateEffect()`.  
   - `Castle` генерирует ресурсы и юнитов.  
   - `ResourceBuilding` приносит один ресурс в неделю.  
   - `BonusBuilding` временно усиливает игрока.  
4. Добавить классы для разных типов игроков (`Knight`, `Mage`, `Ranger`), наследуемые от `Player`.  
5. Переопределить методы движения и бонусов для каждого типа.  

**Примеры промтов для изучения:**  
- Что такое инкапсуляция в объектно-ориентированном программировании?  
- Объясни разницу между наследованием и композицией.  
- Покажи пример полиморфизма с виртуальными методами в C#.  
- Как работает ключевое слово `override` в C#?  

---

### Лабораторная работа 6  
**Темы:** обработка исключений, `StringBuilder`  

**Задачи:**
1. При загрузке файла инвентаря реализовать обработку ошибок (нет файла, поврежденный файл).  
2. Использовать `try-catch` для защиты при преобразовании данных.  
3. При отрисовке карты использовать `StringBuilder` для оптимизации вывода.  
4. При вводе неверной команды игроком — выводить сообщение об ошибке.  

**Примеры промтов для изучения:**  
- Объясни, как работает `try-catch` в C#. Приведи пример обработки исключения.  
- Что такое `finally` и зачем он нужен?  
- Покажи пример использования `StringBuilder` для построения строки в цикле.  
- Чем `StringBuilder` отличается от обычной конкатенации строк?  

---

### Лабораторная работа 7  
**Темы:** интерфейсы, `IEnumerable`, `IEnumerator`, реализация итератора, `foreach`  

**Задачи:**
1. Создать интерфейс `ICollectable` для объектов, которые можно собирать (ресурсы, бонусы).  
2. Сделать коллекцию ресурсов игрока и реализовать в ней `IEnumerable`.  
3. Обеспечить перебор ресурсов через `foreach`.  
4. Добавить итератор для обхода построек на карте.  

**Примеры промтов для изучения:**  
- Что такое интерфейс в C# и чем он отличается от абстрактного класса?  
- Объясни назначение интерфейсов `IEnumerable` и `IEnumerator`.  
- Напиши пример класса, в котором реализован собственный итератор.  
- Как работает цикл `foreach` и почему он требует `IEnumerable`?  

---

### Лабораторная работа 8  
**Темы:** делегаты, анонимные методы, лямбды  

**Задачи:**
1. Создать делегат для обработки событий на карте (например, `OnStep`).  
2. Реализовать подписку на события (сбор ресурса, встреча монстра).  
3. Использовать анонимные методы и лямбды для упрощенной обработки событий.  
4. Сделать делегат для расчета урона в бою (разные формулы для разных классов игроков).  

**Примеры промтов для изучения:**  
- Что такое делегат в C#? Покажи пример его объявления и использования.  
- Объясни разницу между анонимными методами и лямбда-выражениями.  
- Покажи пример использования делегата для обработки события.  
- Как можно использовать лямбду для сортировки списка чисел?  

---

### Лабораторная работа 9  
**Темы:** коллекции, LINQ, замыкания, `IComparable`  

**Задачи:**
1. Хранить монстров на карте в коллекции `List<Monster>`.  
2. Реализовать сортировку монстров по силе с помощью `IComparable`.  
3. Использовать LINQ для выборки объектов (например, все ресурсы определенного типа).  
4. Реализовать замыкание для генерации случайных событий раз в неделю.  

**Примеры промтов для изучения:**  
- Объясни разницу между `List`, `Dictionary`, `Queue` в C#.  
- Покажи пример LINQ-запроса, который выбирает все чётные числа из списка.  
- Что такое замыкание в C# и как оно работает?  
- Как реализовать интерфейс `IComparable` для сортировки объектов по полю `Name`?  

---

### Лабораторная работа 10  
**Темы:** сериализация и десериализация, рефакторинг, паттерны программирования  

**Задачи:**
1. Сохранение/загрузка состояния игры в формате JSON или XML.  
2. Реализовать паттерн Singleton для управления игровой логикой.  
3. Использовать фабрику для создания игроков и юнитов.  
4. Провести рефакторинг кода: вынести повторяющуюся логику, оптимизировать работу с коллекциями.  
5. Собрать финальную версию игры.  

**Примеры промтов для изучения:**  
- Объясни, что такое сериализация и десериализация в C#. Покажи пример с JSON.  
- Что такое паттерн Singleton? Покажи пример его реализации в C#.  
- Объясни, как работает паттерн «Фабрика» или «Фабричный метод».  
- Какие шаги обычно делают при рефакторинге кода?  

---
# Лабораторные работы по курсу C#  
## Проект: Пошаговая стратегия (консольная версия и переход на WPF)

---

## Описание проекта

В рамках курса студенты создают консольную пошаговую стратегию, вдохновлённую механикой серии **Heroes of Might and Magic**.  
Проект развивается от простейшей карты и перемещений игрока до полноценной игры с боями, зданиями, ресурсами и монстрами. Каждая лабораторная работа добавляет новые элементы и закрепляет определённые темы языка C#.

### Общая концепция
- **Карта:** текстовое поле (матрица символов) с игроком, ресурсами, строениями и монстрами. Игрок и захваченные постройки отображаются цветом, нейтральные здания — серые.  
- **Игрок:** перемещается на ограниченное число клеток за день. Тип игрока, уровень и бонусы (конюшня) влияют на скорость. Характеристики хранятся в объектах классов: слоты для юнитов, экипировка, очки заклинаний и передвижения.  
- **Постройки:** замки (генерация ресурсов и юнитов), ресурсные здания (лесопилка, каменоломня, шахта), бонусные строения (конюшня, колодец).  
- **Ресурсы:** случайно расположены на карте, подбираются игроком, начисляются еженедельно.  
- **Монстры:** радиус агрессии, слоты с юнитами, типы — гоблин и хобгоблин.  
- **Информационная панель:** отображает номер недели, текущий день и количество ресурсов игрока.  
- **Сочетания клавиш:** сохранение/загрузка, завершение дня.  

---

# Блок 1. Лабораторные работы для консоли

---

## Лабораторная работа 1  
**Темы:** символы, строки, численные типы данных, ввод/вывод, if-else, for, while  

**Задачи:**
1. Реализовать карту 10x10 с символами (`.`, `#`).  
2. Добавить игрока (`@`) с возможностью перемещаться по карте.  
3. Ограничить движение по границам и стенам.  
4. Выводить координаты игрока.  

**Примеры промтов:**
- Как считать символ с клавиатуры без Enter?  
- Пример движения игрока при W, A, S, D.  
- Цикл игры с обновлением карты.  

---

## Лабораторная работа 2  
**Темы:** массивы, методы, файловый ввод/вывод, DateTime  

**Задачи:**
1. Хранить карту в двумерном массиве.  
2. Разбросать ресурсы (`G`, `W`, `S`).  
3. Подсчет ресурсов и вывод на нижнюю панель.  
4. Сохранение/загрузка игры.  
5. Отображение текущего дня и недели.  

**Примеры промтов:**
- Работа с двумерными массивами.  
- Чтение и запись файлов.  
- Методы для подсчета ресурсов.  

---

## Лабораторная работа 3  
**Темы:** клавиши в консоли, считывание нажатой клавиши  

**Задачи:**
1. Считывать нажатия клавиш (`Console.ReadKey(true)`).  
2. Управление игроком клавишами W, A, S, D.  
3. Настройка клавиш для сохранения/загрузки и завершения дня.  

**Примеры промтов:**
- Пример использования Console.ReadKey.  
- Обработка комбинаций клавиш.  
- Цикл игры с интерактивным вводом.  

---

## Лабораторная работа 4  
**Темы:** отрисовка и перерисовка экрана, нижняя информационная панель  

**Задачи:**
1. Отрисовка карты и игрока.  
2. Очистка экрана и перерисовка после хода.  
3. Нижняя панель с номером недели, днём и ресурсами.  
4. Просмотр информации об игроке (очки движения, заклинаний, экипировка, слоты юнитов).  

**Примеры промтов:**
- Использование Console.Clear() для перерисовки.  
- Отображение нижней панели и данных игрока.  

---

## Лабораторная работа 5  
**Темы:** классы и объекты, структуры, конструкторы, модификаторы видимости, свойства, методы, константы, readonly  

**Задачи:**
1. Создать классы для игрока, монстров, строений, ресурсов.  
2. Использовать конструкторы для инициализации объектов.  
3. Определить свойства, методы и модификаторы доступа.  
4. Разделить игровые элементы на отдельные классы.  

**Примеры промтов:**
- Пример класса игрока с методами перемещения.  
- Как использовать свойства и readonly-поля.  
- Создание класса ресурса с методами для подсчета.  

---

## Лабораторная работа 6  
**Темы:** инкапсуляция, наследование, полиморфизм  

**Задачи:**
1. Наследование классов для разных типов игроков.  
2. Полиморфизм для атак юнитов и магических эффектов.  
3. Защита данных через private/protected поля и свойства.  

**Примеры промтов:**
- Пример наследования игрока: Рыцарь, Маг, Рейнджер.  
- Полиморфный метод атаки для разных юнитов.  
- Использование инкапсуляции для ограничения доступа к полям.  

---

## Лабораторная работа 7  
**Темы:** обработка исключений, StringBuilder  

**Задачи:**
1. Обработка ошибок ввода и неверных действий.  
2. Использование StringBuilder для динамического построения карты и панели информации.  
3. Ловить исключения при сохранении/загрузке игры.  

**Примеры промтов:**
- Пример try/catch при чтении файлов.  
- Как использовать StringBuilder для отрисовки карты.  
- Обработка ошибок при движении игрока.  

---

## Лабораторная работа 8  
**Темы:** интерфейсы, IEnumerable, IEnumerator, реализация итератора, foreach  

**Задачи:**
1. Интерфейсы для коллекций юнитов и строений.  
2. Реализация итераторов для обхода юнитов на карте.  
3. Использование foreach для удобного перебора элементов.  

**Примеры промтов:**
- Пример интерфейса для коллекции юнитов.  
- Реализация IEnumerator для итерации по монстрам.  
- Использование foreach с кастомной коллекцией.  

---

## Лабораторная работа 9  
**Темы:** делегаты, анонимные методы, лямбды  

**Задачи:**
1. Делегаты для событий хода и боя.  
2. Лямбды для фильтрации ресурсов на карте.  
3. Анонимные методы для обработки действий игрока.  

**Примеры промтов:**
- Делегат для события завершения хода.  
- Пример лямбды для поиска монстров на карте.  
- Анонимный метод для обработки кнопки «Следующий ход».  

---

## Лабораторная работа 10  
**Темы:** коллекции, LINQ, замыкания, IComparable  

**Задачи:**
1. Коллекции для юнитов, монстров и строений.  
2. LINQ для фильтрации и сортировки юнитов.  
3. Реализация IComparable для сортировки юнитов по уровню силы.  
4. Использование замыканий для хранения контекста действий.  

**Примеры промтов:**
- Пример сортировки коллекции юнитов с IComparable.  
- LINQ для фильтрации ресурсов на карте.  
- Замыкания для хранения состояния действий игрока.  

---

# Перевод проекта из консоли в WPF

---

## Общая цель
Во втором семестре студенты постепенно переводят консольную пошаговую стратегию в WPF.  
Ключевой принцип: **разделение логики и интерфейса**. Логика игры должна работать независимо от того, в каком интерфейсе она отображается — консоль, WPF или иной.  

---

# Блок 1. Переход на WPF

---

## Лабораторная работа 11.1  
**Тема:** создание многопроектного решения  

### Цель
Научиться создавать несколько проектов в одном решении и настраивать зависимости между ними.  

### Задачи
1. Создать решение с двумя проектами:  
   - библиотека классов (`StrategyGame.Logic`) — содержит игровую механику,  
   - консольное приложение (`StrategyGame.Console`) — использует библиотеку и выводит данные.  
2. Перенести существующие классы логики в `StrategyGame.Logic`.  
3. Подключить `StrategyGame.Logic` к `StrategyGame.Console`.  
4. Продемонстрировать вызов методов из `StrategyGame.Logic` в консольном приложении.  

### Краткое объяснение
Многопроектное решение позволяет разделить ответственность: один проект отвечает за логику, другой за отображение. Это первый шаг к архитектурной чистоте.  

### Примеры промтов
1. Как в Visual Studio создать новое решение с несколькими проектами?  
2. Чем библиотека классов отличается от консольного приложения?  
3. Как добавить ссылку на один проект в другой?  
4. Как вызвать метод из библиотеки классов в консольном приложении?  
5. Покажи пример многопроектного решения на C#.  

---

## Лабораторная работа 11.2  
**Тема:** выделение API логики  

### Цель
Научиться проектировать интерфейс взаимодействия между логикой и интерфейсом.  

### Задачи
1. Реализовать метод в логике, который возвращает текущее состояние карты (например, массив символов).  
2. Реализовать методы управления игроком (движение, проверка коллизий).  
3. Обеспечить минимальную зависимость между проектами: консольный интерфейс не должен изменять внутренние поля логики напрямую.  

### Краткое объяснение
Интерфейс между проектами — это контракт. Интерфейс получает только то, что нужно для отображения и управления, но не знает деталей реализации.  

### Примеры промтов
1. Что такое API в контексте программирования?  
2. Как лучше всего возвращать данные карты из логики для отображения?  
3. Объясни принцип "инкапсуляции" при разделении проектов.  
4. Покажи пример DTO (объект передачи данных) в C#.  
5. Чем опасно, если интерфейс напрямую изменяет внутренние поля логики?  

---

# Блок 2. Основы WPF

---

## Лабораторная работа 12.1  
**Тема:** создание WPF-проекта  

### Цель
Научиться создавать простое WPF-приложение с базовыми элементами управления.  

### Задачи
1. Создать новый WPF-проект `StrategyGame.Desktop`.  
2. Добавить окно `MainWindow` с элементами:  
   - `Canvas` для карты,  
   - `Button` («Следующий ход»),  
   - `Menu` («Новая игра», «Сохранить», «Загрузить»).  
3. Настроить обработчик нажатия кнопки.  
4. Продемонстрировать базовый вывод на Canvas (например, рисование прямоугольника).  

### Краткое объяснение
WPF использует XAML для описания интерфейса. Логика интерфейса реализуется в `MainWindow.xaml.cs`.  

### Примеры промтов
1. Как создать WPF-проект в Visual Studio?  
2. Что такое XAML и как он связан с C#?  
3. Как в WPF добавить кнопку и связать её с событием `Click`?  
4. Как нарисовать прямоугольник на Canvas?  
5. Чем WPF отличается от WinForms?  

---

## Лабораторная работа 12.2  
**Тема:** событийная модель в WPF  

### Цель
Понять принципы событий в WPF и научиться связывать действия пользователя с обновлением интерфейса.  

### Задачи
1. Реализовать обработчики кнопок и пунктов меню.  
2. Сделать событие «Следующий ход», которое обновляет карту.  
3. Научиться очищать и перерисовывать Canvas при изменении данных.  

### Краткое объяснение
WPF работает по событийной модели: любое действие пользователя (клик, нажатие клавиши) вызывает событие, на которое программа подписывается обработчиком.  

### Примеры промтов
1. Что такое событийная модель в WPF?  
2. Как работает подписка на событие в XAML и в коде C#?  
3. Как очистить Canvas и перерисовать его заново?  
4. Объясни разницу между Routed Events и обычными событиями в WPF.  
5. Как связать кнопку с методом обновления интерфейса?  

---

## Лабораторная работа 12.3  
**Тема:** интеграция логики в WPF  

### Цель
Связать библиотеку логики (`StrategyGame.Logic`) с WPF-интерфейсом (`StrategyGame.Desktop`).  

### Задачи
1. Подключить проект `StrategyGame.Logic` к WPF-проекту `StrategyGame.Desktop`.  
2. Реализовать метод, который получает состояние карты из логики.  
3. Отобразить карту на Canvas (клетки — прямоугольники, игрок — эллипс).  
4. Настроить обновление карты при нажатии кнопки «Следующий ход».  

### Краткое объяснение
WPF — это только оболочка. Вся логика остаётся в библиотеке. Интерфейс обращается к логике за данными и перерисовывает Canvas.  

### Примеры промтов
1. Как подключить библиотеку классов к WPF-проекту?  
2. Как из WPF вызвать метод, реализованный в отдельном проекте?  
3. Как отрисовать двумерный массив символов на Canvas?  
4. Покажи пример отрисовки карты, где игрок обозначен кружком.  
5. Как организовать цикл «нажатие кнопки → обновление логики → перерисовка интерфейса»?  
6. Объясни, как отделить отображение от логики в архитектуре программы.  

