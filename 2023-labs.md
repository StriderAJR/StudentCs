# Лаба 1

Пользователь вводит строку с математическим выражением. Гарантируется, что выражение является корректным. В выражении могут быть только операции: +, -, *, /, - и целочисленные числа. Также в строке может быть неизвестное кол-во пробелов. Нужно создать два списка: в один список сохранит все числа из выражения, в другой - операции. Вывести на экран список чисел и список операций.

Пример ввода: 

`12 +5    / 2-0`

Пример вывода:

`12 5 2 0`

`+ / -`

# Лаба 2
Вычислить выражение из предыдущей лабораторной. Не забыть про приоритет операций - умножение и деление вычисляются в первую очередь.

# Лаба 3
В выражении теперь могут быть числа с плавающей запятой и скобки. Переписать программу так, чтобы выражение вычислялось.

Подсказка: Нужно хранить в списке не только символ операции, но и ее приоритет. Когда в выражении встречается открывающаяся сетка, приоритет всех следующих операций повышается на +1. Когда встречается закрывающаяся скобка, приоритет понижается на -1. Умножение и деление имеет приоритет +1 всегда.

Подсказка 2: для хранения нескольких характеристик (операция и ее приоритет) идеально подойдет структура (не класс, а именно структура). Ещё есть тип данных кортеж (Tuple) - это анонимная структура.

# Лаба 4
Изучить, что такое обратная польская запись (ОПЗ). Релизовать алгоритм вычисления результата математического выражения с ее использованием. Алгоритм должен выглядеть следующим образом:
1. Преобразуем строку с привычным математическим выражением (например, `1+20*3`) в список токенов - логически значимых элементов в выражении (например, `[1, +, 20, *, 3]`). Порядок токенов тот же, что был в изначальном выражении
2. Список токенов преобразовать в токены ОПЗ (например, `[1, 20, 3, * +]`)
3. На основе списка токенов, записанных в ОПЗ, вычислить результат выражения
4. Не забывать про разбиение на методы.


Подсказка: чтобы хранить в одном списке и числа, и операции понадобится базовый для всех типов данных тип данных object (List<object>)

# Лаба 5
Изучите что такое структура, класс, объект, конструктор, наследование. Создайте классы `Token, Parenthesis, Number, Operation`. Переделайте список токенов с `List<object>` на `List<Token>`. После изменений, чтобы не писать длинные `operation1.Symbol == operation2.Symbol` и `operation1.Priority > operation2.Priority` можно прочитать про перегрузку операторов и писать более кратко `operation1 == operation2` и `operation1 > operation2`.
Подсказка: наследование пригодится, чтобы классы `Parenthesis, Number и Operation` можно было хранить в одном списке `List<Token>`

# Лаба 6
Добавить графический интерфейс в приложение с ОПЗ. В качестве интерфейса будем использовать WPF - Windows Presentation Foundation.
1. В существующем вашем solution, создать новый проект типа WPF
2. На UI форму добавить следующие компоненты (контролы):
  * TextBox, в которых вводится мат выражение, которое нужно вычислить
  * Label, в который будет записан результат вычисления выражения
  * Button, по нажатию на которую мат выражение будет вычислено и результат записан в Label

Не забывайте, что именовынные контролы (элементы интерфейсы) должны иметь говорящие имена, также как и переменные в коде. Существуют разные конвенции по именованию xaml контролов, от себя могу предложить следующий формат: `lblOutput`, `tbInput`, `btnCalculate`. Сначала идет аббревиатура типа контрола `lbl (Label)`, `tb (TextBox)`, `btn (Button)`. Далее идет 

Скорее всего в ходе реализации логики вычисления ОПЗ в WPF проекте вам пришлось копировать код из консольного приложения в новый проект. Эта проблема будет разбираться в ближайшей лекции.
