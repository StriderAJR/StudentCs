# Лаба 1

Пользователь вводит строку с математическим выражением. Гарантируется, что выражение является корректным. В выражении могут быть только операции: +, -, *, /, - и целочисленные числа. Также в строке может быть неизвестное кол-во пробелов. Нужно создать два списка: в один список сохранит все числа из выражения, в другой - операции. Вывести на экран список чисел и список операций.

Пример ввода: 

`12 +5    / 2-0`

Пример вывода:

`12 5 2 0`

`+ / -`

# Лаба 2
Вычислить выражение из предыдущей лабораторной. Не забыть про приоритет операций - умножение и деление вычисляются в первую очередь.

# Лаба 3
В выражении теперь могут быть числа с плавающей запятой и скобки. Переписать программу так, чтобы выражение вычислялось.

Подсказка: Нужно хранить в списке не только символ операции, но и ее приоритет. Когда в выражении встречается открывающаяся сетка, приоритет всех следующих операций повышается на +1. Когда встречается закрывающаяся скобка, приоритет понижается на -1. Умножение и деление имеет приоритет +1 всегда.

Подсказка 2: для хранения нескольких характеристик (операция и ее приоритет) идеально подойдет структура (не класс, а именно структура). Ещё есть тип данных кортеж (Tuple) - это анонимная структура.

# Лаба 4
Изучить, что такое обратная польская запись (ОПЗ). Релизовать алгоритм вычисления результата математического выражения с ее использованием. Алгоритм должен выглядеть следующим образом:
1. Преобразуем строку с привычным математическим выражением (например, `1+20*3`) в список токенов - логически значимых элементов в выражении (например, `[1, +, 20, *, 3]`). Порядок токенов тот же, что был в изначальном выражении
2. Список токенов преобразовать в токены ОПЗ (например, `[1, 20, 3, * +]`)
3. На основе списка токенов, записанных в ОПЗ, вычислить результат выражения
4. Не забывать про разбиение на методы.


Подсказка: чтобы хранить в одном списке и числа, и операции понадобится базовый для всех типов данных тип данных object (List<object>)

# Лаба 5
Изучите что такое структура, класс, объект, конструктор, наследование. Создайте классы `Token, Parenthesis, Number, Operation`. Переделайте список токенов с `List<object>` на `List<Token>`. После изменений, чтобы не писать длинные `operation1.Symbol == operation2.Symbol` и `operation1.Priority > operation2.Priority` можно прочитать про перегрузку операторов и писать более кратко `operation1 == operation2` и `operation1 > operation2`.
Подсказка: наследование пригодится, чтобы классы `Parenthesis, Number и Operation` можно было хранить в одном списке `List<Token>`
