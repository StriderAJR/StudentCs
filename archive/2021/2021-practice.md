<details>
  <summary>Лабораторная 1. Чтение из файла</summary>
  
  ## Лабораторная 1. Чтение из файла
  **Затрагиваемые темы**: массивы, строки, работа со строками, работа с файлами, списки
  ### Задание
  Даны два вида файлов, которые хранят информацию о событиях и людях. Событие описывается датой, когда оно произошло и описанием проиошедшего. Каждый человек описан в файле уникальным идентификатором, именем, датами рождения и смерти. Файлы могут хранить информацию в нескольких форматах, csv (comma-separated values) и json. Предусмотрите, чтобы программа могла считывать данные из обоих видов файлов. 

  Считайте информацию из обоих файлов. И найдите:
  1. Самое раннее и самое позднее событие, выведите сколько лет, месяцев и дней прошло между ними.
  1. Имена всех людей, которые родились в високосный год и их возраст не более 20 лет.

  ### Примечание
  Первые несколько лабораторных будут разбиты на этапы: логически декомпозированные этапы выполнения задания, которые должны приучить вас самостоятельно декомпозировать большую и страшную задачу на более мелкие. Также сначала будут напоминания по работе с гитом. 

  Правила работы с гитом:
  * Если лабораторные связаны между собой (таймлайны), то каждая лабораторная - это отдельная ветка.
  * Если лабораторная на отдельную тему, то создаем под нее отдельный репозиторий
  * Каждый этап лабораторной - это минимум один коммит
  * После успешного завершения лабораторной, ее ветку нужно подлить в main ветку.

  В дальнейшем подсказки для гита и декомпозиция задания исчезнут и вам придется учиться это делать самостоятельно.

  ### Декомпозиция задачи
  #### Подготовительный этап
  * Создайте проект TimeTrees
  * Подключите папку с солюшеном к гиту
  * Создайте ветку lab1-read-data

  #### Этап 1. Тупое считывание файла и обработка данных в виде строки
  Есть файлы с данными следующего формата:

  timelime.csv
  ```
  {дата_события};{описание_события}
  ```
  Пример файла:
  ```csv
  1950;событие 1 бла-бла-бла
  1991-06-01;какое-то событие 2
  2000-01-01;наступил миллениум, ура-ура-ура
  ```

  people.csv
  ```
  {Имя};{дата_рождения};{дата_смерти}
  ```
  Пример файла:
  ```csv
  1;Имя 1;2000-06-05
  2;Имя 2;1950-01-10;2010-01-01
  ```

  1. Считайте данные из этих файлов в два массива: `string[][] timeline` и `string[][] people`.
  2. Для массива timeline найдите самое раннее и самое позднее событие, выведите сколько лет, месяцев и дней прошло между ними.
  3. Для массива people выведите на экран имена всех людей, которые родились в високосный год и их возраст не более 20 лет.

  #### Этап 2. Переход от строк к общему объекту
  Для каждого пункта вам пришлось конвертировать строку в формат даты и только затем работать с конвертированным форматом. Это лишние вычислительные затраты, которых можно избежать. Рассмотрим другой способ. Он все еще тупой, но для понимания эволюции работы с типами данных проверим и его.

  Для сохранения данных считанных из файла используйте массивы типа не `string[][]`, а `object[][]`. Если вы знаете, что определенный элемент в строке является DateTime, то сразу конвертируйте строку в нужный формат, а полученную переменную сохраняйте в массив `object[][]`. И да, вы должны понимать как такое возможно.

  Теперь при извлечении элемента из массива, если вы знаете, что там дата, то достаточно сделать явное приведение типов (это тоже было отдано на изучение), которое не потребляет вычислительных ресурсов.

  #### Этап 3. Добавились новые данные для человека
  Пока это не очевидно, но для каждого человека нужен уникальный идентификатор, по которому мы сможем кратко ссылаться на человека в разных данных. Такое поле обычно называют Id (Identificator) и оно имеет тип данных int (long  и т.п.) или специальный тип данных, GUID - уникальное значение, которое гарантируется, что не будет повторяться нигде и никогда. В буквальном смысле. Гуиды генерируются по алгоритму таким образом, что нет ни одного повторяющегося в идеале нигде в мире с точностью до погрешности).

  Итак структура файла people.csv поменяется и теперь будет выглядеть следующим образом:
  ```
  {id};{Имя};{дата_рождения};{дата_смерти}
  ```
  Упс. Теперь все индексы в программе сместились. Поменяйте программу так, чтобы она снова работала. Не стесняйтесь придумать что-то, чтобы минимизировать боль, если в файле опять поменяется порядок значений.

  #### Этап 4. Переход от общего объекта к структурам
  Да, индексы и константы это, конечно, хорошо. Но даже если вы сохранили индекс каждого поля в константу (например, `idIndex`, `nameIndex`  и т.д.), то такой код (спойлер) выглядит так себе:
  ```cs
  people[0][birthDateIndex] = DateTime.Parse(parts[birthDateIndex]);
  bool isTwentyOlder = (DateTime.Now.Year - ((DateTime)people[0][birthDateIndex]).Year) > 20;
  ```
  Решением является использовать объединения нескольких переменных в единую сущность. Тогда у кажой переменной будет свой имя. Каждый экземпляр такой сущность - олицетворение одной строчки данных из файла, т.е. одно событие или один человек. Для реализации подобного можно использовать тип данных структуры или класса. Начнем со структур. Посмотрите бегло в любом источнике, что такое структура с С# и создайте две структуры: TimelineEvent и Person, в них создайте нуджные поля с нужными типами данных.

  А затем перепишите вашу программу, чтобы не использовать массив массивов, а использовать массив структур, `TimelineEvent[]` и `Person[]` соответственно.

  #### Этап 5. Работа с файлами JSON
  Если вы все сделали правильно, то следующий этап будет легким. Есть такой формат хранения данных, который называется JSON. Ничего особенного, это определенные правила записи данных, основная идея которого, что у вас есть объединения данных (объекты, как мы сделали в этапе 4), массивы и пары собственно данных формата `{имя_поля}: {значение поля}`. Пример, такого файла для людей:
  ```json
  [
    {
      "id": 1,
      "name": "Human 1",
      "birthDate": "1991-01-01",
      "deathDate": null
    },
    {
      "id": 2,
      "name": "Old Human 1",
      "birthDate": "1941-01-01",
      "deathDate": "2011-12-01"
    }
  ]
  ```
  У нас нет json файла, но мы хотим, чтобы программа умела с ним работать в том числе, а значит нужны тестовые данные. Сохраните массив с объектами событий и людей в файлы `timeline.json` и `people.json` воспользовавшись библиотекой NewtonJson, которую сначала нужно подключить в проект. Затем научите программу считывать данные на выбор или из csv файлов, или из json файлов.

  Как подключить библиотеку в проект читаем здесь:
  * Для VS https://docs.microsoft.com/ru-ru/nuget/quickstart/install-and-use-a-package-in-visual-studio
  * Для Rider https://www.jetbrains.com/help/rider/Using_NuGet.html

  Как использовать библиотеку: https://www.newtonsoft.com/json/help/html/SerializingJSON.htm

  PS: вы также должны в дальнейшем разобраться что такое NuGet, что такое сериализация и десериализация.
    
</details>
  
<details>
  <summary>Лабораторная 2. Добавление данных и сохранение в файл</summary>
  
  ## Лабораторная 2. Добавление данных и сохранение в файл
  Не забудьте создать ветку и делать коммиты между этапами, описанными в лабораторной, или между каждым успешно написанным кодом, который вы хотите сохранить. Воспринимайте коммиты как чек-поинты в игре, на которые вы сможете откатиться в случае "смерти" (зашли в тупик или что-то сломалось).
  
  ### Этап 1. Сделать ввод данных для события и человека
  1. Для события пользователь вводит с экрана дату, описание события и айдишники людей, которые участвовали в этом событии.
  ```
    * нельзя ввести айдишник человека, который еще не введен в программе
    * дату ввести можно: только год, год и месяц или точную дату
    * предусмотреть проверку корректности ввода даты
  ```
  2. Для человека с экрана вводится имя, дата рождения и дата смерти. Если человек еще жив, то дата смерти будет пустой. Затем для человека вводится идентификатор родителей.
  ```
    * родителей может быть только двое
    * пол родителей неважен (мы тут все прогрессивные)
    * может быть указан как только один родитель, так и ни одного (сироты и всякое такое)
    * при указании родителя проверять, что такой человек существует в системе
    * естественно проверять корректность ввода даты рождения и смерти
  ```
  
  ### Этап 2. Поиск людей при вводе данных
  Указывать при вводе событий и новых людей айдишники не очень удобно, хочется оперировать все-таки человекочитаемыми данными. Поэтому во время ввода данных, делаем возможность провалиться внутрь поиска людей, где мы начинаем вводить имя человека, программа показывает список доступных людей, а пользователь выбирает из списка нужного. и его данными уже заполняется. (Пример работы с таким меню требуем у препода).
  
  Описание примера организации меню на примере ввода данных нового человека.
  - Программа: "введите имя человека"
  - Юзер: "вводит какое-то имя"
  - Программа: "введите дату рождения и смерти"
  - Юзер: "вводит одну или две даты"
  - Программа проверяет корретность введенных дат, если даты некорректны, то выводит текст ошибки и просит повторить ввод даты или прервать создание нового человека. Если все корретно, то переходим к следующему пункту.
  - Программа: "Нажмите Enter, если у человека неизвестны родители или кнопку F, чтобы найти родственников"
  - Юзер: "нажимает F"
  - Программа очищает экран, появляется текст "начните вводить имя первого родителя" и на строке пустое поле, где будут вводиться символы для поиска
  - Юзер: "вводит первый символ"
  - Программа опять очищает экран, но таким образом, чтобы на экране создавалось впечатление, что увеличивается только поле ввода символов для поиска и меняется список найденных людей.
  
  ```
    * сделайте систему поиска людей при вводе данных
    * сделайте выбор человека в списке с помощью клавиш вверх/вниз, а не с помощью цифр
  ```
  
  ### Этап 3. Редактирование данных
  Сделайте меню выбора имеющегося человека в системе и возможность отредактировать его данные
  
  ### Этап 4. Вывод на экран и в файл
  Сделайте вывод списка людей и событий в консоль простым списком, если это еще не сделано. Также сделайте сохранение данных в csv и в json файлы. При старте программы загружайте данные либо из csv, либо из json файла, чтобы восстановить работу с программой с прошлого раза.
  
  ### Этап 5. Переход на классы
  Скорее всего программа уже представляет из себя кучу отдельных методов, в которых уже сложно ориентироваться. Часть из этих методов связана друг с другом в рамках одного функционала, другие методы не имеют между собой прямой связи. Перед тем как переходить к следующим этапам разбейте программу на классы. Рассказать про логику разбиения на классы и отличие классов от структур должен преподаватель.
</details>


<details>
  <summary>Лабораторная 3. Форматированный вывод на экран</summary>
  
  ## Лабораторная 3. Форматированный вывод на экран
  Here be dragons
</details>

<details>
  <summary>Описание проекта</summary>
  
  # Описание проекта
  В рамках проекта, который будет развиваться до конца курса будет реализована программа, которая позволит создавать таймлайны
  
  ## Таймлайн
  Таймлайн - это события, упорядоченные по времени. Таймлайн может иметь текстовое представление

  <img src="https://user-images.githubusercontent.com/2069875/132652913-ac7fa96c-c843-40d6-9d1e-3e2eb411bcfd.png" height="250">

  или графическое

  <img src="https://user-images.githubusercontent.com/2069875/132653017-551b8ba4-bf81-432b-a488-8b24e6d8fc25.png" height="250">

  ## Генеалогическое древо
  Генеалогическое древо вляется одной из вариаций таймлайна но отражаются в нем только события, связанные с определенными людьми, и отношения между ними. Чаще всего генеалогическое древо строится в графическом виде и на нем отображаются события рождения и смерти людей из одной семьи/рода.

  <img src="https://user-images.githubusercontent.com/2069875/132661659-9d5aafd3-6f03-4048-98c7-32ccb07b149f.png" height="250">

  Иногда генеалогическое древо может расширяться дополнительными событиями, касающимися определенных людей, чтобы было видно, что он не только родился и умер, но и поучаствовал в некоторых событиях.
  ## Связь таймлайна и генеалогического древа
  В событиях таймлайна могут встречаться люди, для которых существует генеалогическое древо. Соответственно, выбрав человека на таймлайне, можно провалиться в его генеалогическое древо.

  ## Для чего нужны таймлайны и генеалогические древа
  Таймлайны это удобный и наглядный способ изучения, например, истории. Но также они могут использоваться в фандомах для лучшего слежения за ходом событий в мультисюжетных вселенных (Сталкер, WarHammer, Метро). Генеалогические деревья также используются для иллюстраций сложных взаимоотношений между персонажами (Властелин колец, Ведьмак).
</details>

<details>
  <summary>Лабораторная 4. Связи между объектами</summary>
  
  # Лабораторная 4. Связи между объектами
  Here be dragons
</details>
